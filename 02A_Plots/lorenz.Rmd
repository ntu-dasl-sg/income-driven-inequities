---
title: "Income inequality"
author: "Jeanette Choong"
date: "2023-12-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(raster)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(scales)
library(data.table)
library(stats)
library(janitor)
```


In this document, we plot the lorenz curve and compute the Gini coefficient for households in the Philippines. 

The Lorenz curve was developed by Max O. Lorenz in 1905, to highlight inequality in income/wealth distribution. The curve thus shows the cumulative proportion of income possessed by a certain cumulative proportion of the population. This concept has since been applied to multiple disciplines as a measure of inequality. In this case, we plot the Lorenz curve to understand income distribution amongst households in the Philippines. 

The Gini coefficient is calculated as the ratio of the area bounded by the line of perfect equality (45 degree dotted line) and the Lorenz curve, divided by the area under the line of perfect equality. The higher the coefficient i.e. closer to 1, the more inequality exists in the distribution.


## 1. Income inequality 

We start by plotting the income inequality, which is the conventional use case of a Lorenz curve. 

```{r}
# Load rasters
labour_income_rast <- raster("/Users/jeancjw/Documents/00_Data/Income expenditure savings 2021/Labour income rasters/labour_income_merged.tif")

building_rast <- raster("/Users/jeancjw/Documents/00_Data/Buildings/buildingcount_90m.tif")

labour_income_rast[is.na(building_rast)] <- NA

```

Then we convert them to points.

```{r}
income_pts <- rasterToPoints(labour_income_rast)
building_pts <- rasterToPoints(building_rast)

head(income_pts)
```

```{r}
# Check if 'x' and 'y' coordinates are the same for every row
coordinates_match <- all.equal(income_pts[, c("x", "y")], building_pts[, c("x", "y")]) # check building_pts as well. This code cannot compare 3 data frames.

if (is.logical(coordinates_match) && all(coordinates_match)) {
  print("Coordinates are the same for every row.")
} else {
  stop("Coordinates are not the same for every row. Check your data.")
}
```

```{r}
# Combined points into data frame 

income_buildings <- cbind(income_pts[, "layer"], building_pts[, "layer"]) #'layer' is just the name of the col containing flood depth, income and building values in each df/matrix; we pick the layer column as we don't need x & y coordinates

head(income_buildings) # check: column 1 is income, column 2 is number of buildings
```

```{r}
# Rename columns for clarity
colnames(income_buildings) <- c("income", "buildings")

head(income_buildings) # check
```

Now we want to expand the data frame such that each row represents one building.

```{r}
income_buildings <- data.table(income_buildings) # convert matrix to df
# income_buildings <- income_buildings %>% 
  # select(-x,-y) # remove x y coordinates; we don't need this

# Replicate rows c(income, depth) based on number of buildings 
## note: requires income_buildings to be in data.table format; doesn't work with income_buildings frame
income_buildings <- income_buildings[, .(income = rep(income, buildings)), by = 1:nrow(income_buildings)] 

income_buildings # check income_buildings
```

```{r}
# Filter only buildings with income 
income_buildings <- income_buildings %>% 
  filter(income != 0) %>% 
  arrange(income)
```

### 1.1 [Bldg] Lorenz curve data

```{r Create lorenz curve}
# Household incomes
household_incomes <- income_buildings$income

# Step 1: Sort incomes in ascending order
sorted_incomes <- sort(household_incomes)

# Step 2: Calculate cumulative percentage of total income
cumulative_percentage <- cumsum(sorted_incomes) / sum(sorted_incomes) * 100

# Create a data frame for ggplot
lorenz_data <- data.frame(
  Percentage_Households = seq(0, 100, length.out = length(sorted_incomes)),
  Cumulative_Percentage = cumulative_percentage
)

lorenz_data
```

### 1.2 [Bldg] Plot Lorenz curve

```{r}
# Create a ggplot object with Lorenz curve and shaded area
ggplot(lorenz_data, aes(x = Percentage_Households, y = Cumulative_Percentage)) +
  geom_ribbon(aes(ymin = pmin(Percentage_Households, Cumulative_Percentage), 
                  ymax = pmax(Percentage_Households, Cumulative_Percentage)), 
              fill = "lightblue", 
              alpha = 0.5) +
  geom_abline(slope = 1, 
              intercept = 0, 
              linetype = "dashed", 
              color = "black") + # 45 deg line representing perfect equality
  geom_line(color = "#294475",
            size = 1) + 
  labs(x = "Cumulative percentage of households",
       y = "Cumulative percentage of household incomes") +
  theme_bw() + 
  scale_x_continuous(limits = c(0, 100), expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0))
```


```{r}
# Load the stats package (if not already loaded)
# Calculate Gini coefficient function
calculate_gini <- function(cumulative_percentage_households, cumulative_percentage_income) {
  # n <- length(cumulative_percentage_households)
  
  # Step 1: Define the Lorenz curve function
  lorenz_curve <- approxfun(cumulative_percentage_households, cumulative_percentage_income, method = "linear", yleft = 0, yright = 100)
  
  # Step 2: Calculate the area under the Lorenz curve between 0 and 100
  area_under_curve <- integrate(lorenz_curve, 0, 100)$value
  
  # Step 3: Calculate total area under 45-degree line
  area_under_45_degree_line <- 0.5 * 100 * 100
  
  # Step 4: Calculate Gini coefficient
  gini_coefficient <- 2 * (area_under_45_degree_line - area_under_curve) / area_under_45_degree_line
  
  return(gini_coefficient)
}

# Calculate Gini coefficient
gini <- calculate_gini(lorenz_data$Percentage_Households, lorenz_data$Cumulative_Percentage)

cat("Gini Coefficient:", gini, "\n")
print("The Gini coefficient of households affected by flooding only. This shows high income inequality.")
```

###  Population instead of buildings

Just checking if we get the same figure of 40.2% for the Gini coefficient when using population rather than building data. 

```{r}
# Load rasters
labour_income_rast_pop <- raster("/Users/jeancjw/Documents/00_Data/Income expenditure savings 2021/Labour income rasters/labour_income_merged.tif")

pop_rast <- raster("/Users/jeancjw/Documents/00_Data/Population/phl_ppp_2020_constrained.tif") 

# Ensure the same resolution
pop_rast <- resample(pop_rast, labour_income_rast_pop)

# Adjust extent
pop_rast <- setExtent(pop_rast, extent(labour_income_rast_pop), keepres = TRUE)


# both rasters are in the same projection and resolutoin but different extent
labour_income_rast_pop[is.na(pop_rast)] <- NA # find labour income only where there are people

# compareRaster(labour_income_rast_pop, pop_rast)
# plot(labour_income_rast_pop)
```

Then we convert them to points.

```{r}
income_pop_pts <- rasterToPoints(labour_income_rast_pop)
pop_pts <- rasterToPoints(pop_rast)

head(pop_pts)
```

```{r}
head(income_pop_pts)
```


```{r}
income_pop <- merge(income_pop_pts, pop_pts, by = c("x", "y")) 

head(income_pop)
```


```{r}
# Rename columns for clarity
colnames(income_pop) <- c("x", "y","income", "population")

head(income_pop) # check
```

Now we want to expand the data frame such that each row represents one person

```{r}
income_pop_data <- income_pop %>%
  slice(rep(row_number(), population)) %>%
  select(-population, -x, -y) 
income_pop_data # check income_pop_data
```

```{r}
# Filter only buildings with income 
income_pop_data <- income_pop_data %>% 
  filter(income != 0) %>% 
  arrange(income)


```

### 2.1 [Pop] Lorenz curve data

```{r Create lorenz curve}
# Household incomes
pop_income <- income_pop_data$income

# Step 1: Sort incomes in ascending order
sorted_incomes <- sort(pop_income)

# Step 2: Calculate cumulative percentage of total income
cumulative_percentage <- cumsum(sorted_incomes) / sum(sorted_incomes) * 100

# Create a data frame for ggplot
lorenz_data_pop <- data.frame(
  Percentage_Population = seq(0, 100, length.out = length(sorted_incomes)),
  Cumulative_Percentage = cumulative_percentage
)

lorenz_data_pop
```

### 2.2 [Pop]  Plot Lorenz curve

```{r}
# Sample lorenz data as there are too many rows
set.seed(42)
lorenz_data_popsamp <- lorenz_data_pop %>%
  sample_n(size = 500000) 
```


```{r}
# Create a ggplot object with Lorenz curve and shaded area
lorenz_data_popsamp %>% 
ggplot(aes(x = Percentage_Population, y = Cumulative_Percentage)) +
  geom_ribbon(aes(ymin = pmin(Percentage_Population, Cumulative_Percentage), 
                  ymax = pmax(Percentage_Population, Cumulative_Percentage)), 
              fill = "lightblue", 
              alpha = 0.5) +
  geom_abline(slope = 1, 
              intercept = 0, 
              linetype = "dashed", 
              color = "black") + # 45 deg line representing perfect equality
  geom_line(color = "#294475",
            size = 1) + 
  labs(x = "Cumulative percentage of population",
       y = "Cumulative percentage of household incomes") +
  theme_bw() + 
  scale_x_continuous(limits = c(0, 100), expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0))
```


```{r}
# Load the stats package (if not already loaded)
# Calculate Gini coefficient function
calculate_gini <- function(cumulative_percentage_households, cumulative_percentage_income) {
  # n <- length(cumulative_percentage_households)
  
  # Step 1: Define the Lorenz curve function
  lorenz_curve <- approxfun(cumulative_percentage_households, cumulative_percentage_income, method = "linear", yleft = 0, yright = 100)
  
  # Step 2: Calculate the area under the Lorenz curve between 0 and 100
  area_under_curve <- integrate(lorenz_curve, 0, 100)$value
  
  # Step 3: Calculate total area under 45-degree line
  area_under_45_degree_line <- 0.5 * 100 * 100
  
  # Step 4: Calculate Gini coefficient
  gini_coefficient <- 1-2*(area_under_45_degree_line - area_under_curve) / area_under_45_degree_line
  
  return(gini_coefficient)
}

# Calculate Gini coefficient
gini <- calculate_gini(lorenz_data_popsamp$Percentage_Population, lorenz_data_popsamp$Cumulative_Percentage)

cat("Gini Coefficient:", gini, "\n")
print("The Gini coefficient of households affected by flooding only. This shows high income inequality.")
```

This is close to the reported gini coefficient of the Philippines (40.2%)

## 2. Flood exposure inequality

Now we plot the same thing but for flood exposure to show that sea level rise increases the extent of the inequality in exposure. 

```{r}
# Load rasters
flood_rast_2020 <- raster("/Users/jeancjw/Documents/00_Data/Coastal flood maps/Philippines/RCP45/Y2020/merged/merge_Y2020_RP100.tif") # year 2020
flood_rast_2050 <- raster("/Users/jeancjw/Documents/00_Data/Coastal flood maps/Philippines/RCP45/Y2050/merged/merge_Y2050_RP100.tif") # year 2050

building_rast <- raster("/Users/jeancjw/Documents/00_Data/Buildings/buildingcount_90m.tif")
labour_income_rast <- raster("/Users/jeancjw/Documents/00_Data/Income expenditure savings 2021/Labour income rasters/labour_income_merged.tif")
```

### 2.1 Flood Y2020

```{r}
# Create data frame from raster values
flood_2020 <- data.frame(flood_depths = getValues(flood_rast_2020),
                         income = getValues(labour_income_rast),
                         num_households = getValues(building_rast))

# Filter data for households that experience flooding, num_households is not NA
flooded_data_2020 <- subset(flood_2020, !is.na(num_households) & flood_depths > 0 & income > 0)

flooded_data_2020
```


```{r}
# Replicate rows based on num_households
flooded_data_2020 <- flooded_data_2020 %>%
  slice(rep(row_number(), num_households)) %>%
  select(-num_households) 

flooded_data_2020
```

```{r}
## Arrange flood_depths in order of increasing depth

flooded_data_2020 <- flooded_data_2020 %>% 
  arrange(flood_depths, -income)

flooded_data_2020 <- flooded_data_2020 %>% 
  mutate(income_category = ifelse(income <= pov_line_intl, "Below poverty line", "Above poverty line"))


flooded_data_2020
```

#### 2.1.1 Make lorenz curve data
```{r}
lorenz_flood_20 <-data.frame(
  cum_perc_households = seq(0, 100, length.out = length(flooded_data_2020$income)),
  cum_flood = cumsum(flooded_data_2020$flood_depths) / sum(flooded_data_2020$flood_depths)*100, 
  income = flooded_data_2020$income,
  income_category = flooded_data_2020$income_category)

lorenz_flood_20
```

#### 2.1.2 Plot Lorenz curve for flood in 2020

```{r}
lorenz_flood_20 %>% 
ggplot(aes(x = cum_perc_households , y = cum_flood)) +
  geom_ribbon(aes(ymin = pmin(cum_perc_households, cum_flood), 
                  ymax = pmax(cum_perc_households, cum_flood)), 
              fill = "lightblue", 
              alpha = 0.5) +
  geom_line(color = "#294475", linewidth = 1) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +
  labs(x = "Cumulative share of households (%) in order of decreasing income",
       y = "Cumulative share of flooding (%)") + 
  theme_bw() + 
  scale_x_continuous(limits = c(0, 100), expand = c(0.008, 0)) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0))
```

#### 2.1.3 Splitting Lorenz curve by pov line
```{r}
## Splitting of lorenz curves 
flooded_data_2020 # already includes the income categorisation

## Split into two income groups
flooded_data_2020_BPov <- flooded_data_2020 %>% 
  filter(income_category == "Below poverty line") # below poverty line only

flooded_data_2020_APov <- flooded_data_2020 %>% 
  filter(income_category == "Above poverty line") # below poverty line only

## Make Lorenz curve data

lorenz_BPov <- data.frame(
  cum_perc_hh = seq(0,100, length.out = length(flooded_data_2020_BPov$income)),
  cum_flood = cumsum(flooded_data_2020_BPov$flood_depths_20) / sum(flooded_data_2020_BPov$flood_depths_20) * 100,
  income = flooded_data_2020_BPov$income,
  income_category = flooded_data_2020_BPov$income_category
)

lorenz_APov <- data.frame(
  cum_perc_hh = seq(0,100, length.out = length(flooded_data_2020_APov$income)),
  cum_flood = cumsum(flooded_data_2020_APov$flood_depths_20) / sum(flooded_data_2020_APov$flood_depths_20) * 100,
  income = flooded_data_2020_APov$income,
  income_category = flooded_data_2020_APov$income_category
)

## Plot Lorenz Curve
ggplot() + 
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +
  geom_line(data = lorenz_APov,
            aes(x = cum_perc_hh, y = cum_flood),
            color = "#EB6134") +
  geom_line(data = lorenz_BPov, 
            aes(x = cum_perc_hh, y = cum_flood),
            color = "#294475",
            linewidth = 0.6) + 
  labs(x = "Cumulative share of households (%) in order of decreasing income",
                                 y = "Cumulative share of flooding (%)") +
  theme_bw() +
  scale_x_continuous(limits = c(0, 100), expand = c(0.01, 0)) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) 

```


### 2.2 Flood Y2050
```{r}
# Create data frame from raster values
flood_data <- data.frame(flood_depths_50 = getValues(flood_rast_2050), 
                         flood_depths_20 = getValues(flood_rast_2020),
                         income = getValues(labour_income_rast),
                         num_households = getValues(building_rast))


# Filter data for households that experience flooding, num_households is not NA
flooded_data <- subset(flood_data, !is.na(num_households) & flood_depths_50 > 0 & income > 0)
```



```{r}
# Replicate rows based on num_households
flooded_data <- flooded_data %>%
  slice(rep(row_number(), num_households)) %>%
  select(-num_households) 

flooded_data
```



```{r}
## Split data into two years as they have different number of rows
flooded_data_2020 <- flooded_data %>%
  select(-flood_depths_50) %>% 
  filter(flood_depths_20 > 0) %>% 
  arrange(flood_depths_20,-income) # arrange according to decreasing income (cos the lower the income the higher the flood exposure)

flooded_data_2020


flooded_data_2050 <- flooded_data %>% 
  select(-flood_depths_20) %>% 
  arrange(flood_depths_50, -income) # arrange according to decreasing income (cos the lower the income the higher the flood exposure)

flooded_data_2050
```



#### 2.2.1 Make lorenz curve data
```{r}
lorenz_data_20 <-data.frame(
  cum_perc_households = seq(0, 100, length.out = length(flooded_data_2020$income)),
  cum_flood20 = cumsum(flooded_data_2020$flood_depths_20) / sum(flooded_data_2020$flood_depths_20)*100)

lorenz_data_20
```

####


For 2050
```{r}
lorenz_data_50 <- data.frame(
  cum_perc_households = seq(0,100, length.out = length(flooded_data_2050$income)), 
  cum_flood50 = cumsum(flooded_data_2050$flood_depths_50 / sum(flooded_data_2050$flood_depths_50)*100)
)
lorenz_data_50
```


#### 2.2.2 Plot Lorenz curve for flood in 2020 and 2050

```{r}
ggplot() + 
  geom_line(data = lorenz_data_20, 
            aes(x = cum_perc_households, y = cum_flood20), 
            color = "#EB6134") + 
   geom_line(data = lorenz_data_50, 
            aes(x = cum_perc_households, y = cum_flood50), 
            color = "#3773a3") + 
   geom_abline(intercept = 0, slope = 1, linetype = "dotted", color = "black") +
  labs(x = "Cumulative share of households (%) in order of decreasing income",
       y = "Cumulative share of flooding (%)") +
  theme_bw() +
  scale_x_continuous(limits = c(0, 100), expand = c(0.01, 0)) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) 
```


#### 2.2.3 Calculate Gini

```{r}
calculate_gini(lorenz_data_20$cum_perc_households, lorenz_data_20$cum_flood20)
```

```{r}
calculate_gini(lorenz_data_50$cum_perc_households, lorenz_data_50$cum_flood50)
```

## 3. Consumption inequality

Now we plot lorenz curves to show the inequality in consumption levels before and after a 100-year flood in 2050
### 3.1 Data prep 

```{r}
# read consumption raster
c0_rast_50 <- raster("/Users/jeancjw/Documents/03_Results/Rasters/PH/merged/C0_Y2050.tif")
ct_rast_50 <- raster("/Users/jeancjw/Documents/03_Results/EAD/PH/wo_buildings/C_PH_Y2050.tif") # expected annual consumption
```

```{r}
# convert to points
c0_50_pts <- rasterToPoints(c0_rast_50)
ct_50_pts <- rasterToPoints(ct_rast_50)

ct_50_pts
```



```{r}
# merge with income and num_buildings
consumption50 <- merge(c0_50_pts,ct_50_pts, by =c("x", "y"))
consumption50- merge(consumption50, income_pts, by =c("x", "y"))
consumption50 <- merge(consumption50, building_pts, by =c("x", "y"))
consumption50
```

```{r}
# change column names 
colnames(consumption50) <- c("x", "y", "c0", "ct", "income", "num_buildings")

consumption50
```

```{r}
# Expand data frame such that every row is one building
loss_income_data_20  <- loss_income_data_20 %>%
  slice(rep(row_number(), num_buildings)) %>%
  select(-num_buildings, -x, -y) 


```


```{r}

# Create data frame from raster values
c0_2050 <- data.frame(c0_50 = getValues(c0_rast_50),
                      ct_50 = getValues(ct_rast_50),
                      income = getValues(labour_income_rast),
                      num_households = getValues(building_rast))

# c0_2050 <- subset(c0_2050, !is.na(num_households) & income > 0)

c0_2050 <- c0_2050 %>% 
  filter(income > 0) %>% 
  filter(!is.na(num_buildings))

c0_2050
```
### 3.1 Make lorenz curve data
```{r}
# Replicate rows based on num_households
consumption_data_2050 <- c0_2050%>%
  slice(rep(row_number(), num_households)) %>%
  select(-num_households) 

# consumption_data_2050 <- consumption_data_2050 %>% 
#   mutate(c0_50 = c0_50 + abs(min(consumption_data_2050$ct_50))) %>% 
#   mutate(ct_50 = ct_50 + abs(min(consumption_data_2050$ct_50)))
consumption_data_2050$ct_50[consumption_data_2050$ct_50 < 0] <- 0
```

```{r}
consumption_data_2050 <- consumption_data_2050 %>% 
  arrange(c0_50, income) # arrange according to increasing income

lorenz_c0_data <-data.frame(
  cum_perc_households = seq(0, 100, length.out = length(consumption_data_2050$income)),
  cum_c0 = cumsum(consumption_data_2050$c0_50) / sum(consumption_data_2050$c0_50)*100)

lorenz_c0_data
```

```{r}
lorenz_ct_data <- data.frame(
  cum_perc_households = seq(0, 100, length.out = length(consumption_data_2050$income)),
  cum_ct = cumsum(consumption_data_2050$ct_50) / sum(consumption_data_2050$ct_50)*100)

lorenz_ct_data
```
### 3.2 Plot lorenz before and after flood (Y2050)
```{r}
ggplot() + 
  geom_line(data = lorenz_c0_data, 
            aes(x = cum_perc_households, y = cum_c0), 
            color = "#EB6134") + 
   geom_line(data = lorenz_ct_data, 
            aes(x = cum_perc_households, y = cum_ct), 
            color = "#3773a3") + 
   geom_abline(intercept = 0, slope = 1, linetype = "dotted", color = "black") +
  labs(x = "Cumulative share of households (%) in order of increasing income",
       y = "Cumulative share of consumption (%)") +
  theme_bw() 
  # scale_x_continuous(limits = c(0, 100), expand = c(0.01, 0)) +
  # scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) 
```
```{r}
  
# Step 1: Define the Lorenz curve function
lorenz_curve <- approxfun(lorenz_ct_data$cum_perc_households, lorenz_ct_data$cum_ct, method = "linear", yleft = 0, yright = 100)

# Step 2: Calculate the area under the Lorenz curve between 0 and 100
area_under_curve <- integrate(lorenz_curve, 0, 100)$value

# Step 3: Calculate total area under 45-degree line
area_under_45_degree_line <- 0.5 * 100 * 100

# Step 4: Calculate Gini coefficient
gini_coefficient <- ((area_under_45_degree_line - area_under_curve) / area_under_45_degree_line)

gini_coefficient
```

### 3.3 Calculate Gini

```{r}
calculate_gini(lorenz_c0_data$cum_perc_households, lorenz_c0_data$cum_flood50)
# Step 1: Define the Lorenz curve function
lorenz_curve <- approxfun(lorenz_c0_data$cum_perc_households, lorenz_c0_data$cum_c0, method = "linear", yleft = 0, yright = 100)

# Step 2: Calculate the area under the Lorenz curve between 0 and 100
area_under_curve <- integrate(lorenz_curve, 0, 100)$value

# Step 3: Calculate total area under 45-degree line
area_under_45_degree_line <- 0.5 * 100 * 100

# Step 4: Calculate Gini coefficient
gini_coefficient <- ((area_under_45_degree_line - area_under_curve) / area_under_45_degree_line)

gini_coefficient
```

## 4. Asset and welfare losses

### 4.1 Data prep

#### 4.1.1 2020
```{r}
# Read data
AL20_rast <- raster("/Users/jeancjw/Documents/03_Results/EAD/PH/wo_buildings/AL_PH_Y2020.tif")
WL20_rast <- raster("/Users/jeancjw/Documents/03_Results/EAD/PH/wo_buildings/WL_PH_Y2020.tif")
```
```{r}
# convert to points

AL20_pts <- rasterToPoints(AL20_rast)
WL20_pts <- rasterToPoints(WL20_rast)

head(AL20_pts)
```

```{r}
# merge with income and num_buildings
loss_income_data_20 <- merge(AL20_pts, WL20_pts, by =c("x", "y"))
loss_income_data_20 <- merge(loss_income_data_20, income_pts, by =c("x", "y"))
loss_income_data_20 <- merge(loss_income_data_20, building_pts, by =c("x", "y"))
loss_income_data_20
```

```{r}
# change column names 
colnames(loss_income_data_20) <- c("x", "y", "AL20", "WL20", "income", "num_buildings")

loss_income_data_20
```

```{r}
# Expand data frame such that every row is one building
loss_income_data_20  <- loss_income_data_20 %>%
  slice(rep(row_number(), num_buildings)) %>%
  select(-num_buildings, -x, -y) 


```
#### 4.1.2 2050
```{r}
# Read data
AL50_rast <- raster("/Users/jeancjw/Documents/03_Results/EAD/PH/wo_buildings/AL_PH_Y2050.tif")
WL50_rast <- raster("/Users/jeancjw/Documents/03_Results/EAD/PH/wo_buildings/WL_PH_Y2050.tif")
```

```{r}
# convert to points

AL50_pts <- rasterToPoints(AL50_rast)
WL50_pts <- rasterToPoints(WL50_rast)

head(AL50_pts)
```

```{r}
# merge with income and num_buildings
loss_income_data_50 <- merge(AL50_pts, WL50_pts, by =c("x", "y"))
loss_income_data_50 <- merge(loss_income_data_50, income_pts, by =c("x", "y"))
loss_income_data_50 <- merge(loss_income_data_50, building_pts, by =c("x", "y"))
loss_income_data_50
```

```{r}
# change column names 
colnames(loss_income_data_50) <- c("x", "y", "AL50", "WL50", "income", "num_buildings")

loss_income_data_50
```

```{r}
# Expand data frame such that every row is one building
loss_income_data_50  <- loss_income_data_50 %>%
  slice(rep(row_number(), num_buildings)) %>%
  select(-num_buildings, -x, -y) 

loss_income_data_50 
```

### 4.2 Make lorenz curve data

#### 4.2.1 2020
```{r}
loss_income_data_ <- loss_income_data_20 %>% 
  arrange(AL20, income) # arrange according to increasing income

lorenz_loss20_data <-data.frame(
  cum_perc_households = seq(0, 100, length.out = length(loss_income_data_20$income)),
  cum_AL20 = cumsum(loss_income_data_20$AL20) / sum(loss_income_data_20$AL20) * 100,
  cum_WL20 = cumsum(loss_income_data_20$WL20) / sum(loss_income_data_20$WL20) * 100)

lorenz_loss20_data
```
#### 4.2.2 2050

```{r}
loss_income_data_50 <- loss_income_data_50 %>% 
  arrange(AL50, income) # arrange according to increasing income

lorenz_loss50_data <-data.frame(
  cum_perc_households = seq(0, 100, length.out = length(loss_income_data_50$income)),
  cum_AL50 = cumsum(loss_income_data_50$AL50) / sum(loss_income_data_50$AL50) * 100,
  cum_WL50 = cumsum(loss_income_data_50$WL50) / sum(loss_income_data_50$WL50) * 100)

lorenz_loss50_data
```


### 4.3 Plot Lorenz curve 


#### 4.3.1 2020

```{r}
colnames(lorenz_loss20_data) <- c("cum_perc_households", "Asset loss", "Welfare loss")

lorenz_loss20_data_long <- lorenz_loss20_data %>%
  gather(key = "loss_Type", value = "cum_Loss", -cum_perc_households)

lorenz_loss20_data_long
```

```{r}
ggplot(lorenz_loss20_data_long, 
       aes(x = cum_perc_households, y = cum_Loss, color = loss_Type)) + 
  geom_line() + 
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") +
  labs(x = "Cumulative share of households (%) in order of increasing income",
       y = "Cumulative share of losses (%)") +
  theme_bw() +
  scale_color_manual(values = c("#EB6134", "#3773a3"), 
                     name = "Loss Type",
                     labels = c("Asset Losses", "Welfare Losses"))

```
#### 4.3.2 2050

```{r}
colnames(lorenz_loss50_data) <- c("cum_perc_households", "Asset loss", "Welfare loss")

lorenz_loss50_data_long <- lorenz_loss50_data %>%
  gather(key = "loss_Type", value = "cum_Loss", -cum_perc_households)

lorenz_loss50_data_long
```

```{r}
ggplot(lorenz_loss50_data_long, 
       aes(x = cum_perc_households, y = cum_Loss, color = loss_Type)) + 
  geom_line() + 
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") +
  labs(x = "Cumulative share of households (%) in order of increasing income",
       y = "Cumulative share of losses (%)") +
  theme_bw() +
  scale_color_manual(values = c("#EB6134", "#3773a3"), 
                     name = "Loss Type",
                     labels = c("Asset Losses", "Welfare Losses"))

```

#### 4.3.3 Asset losses 2020 + 2050

```{r}
# clean column names for easy plotting
lorenz_loss20_data <- lorenz_loss20_data %>% 
  clean_names()
lorenz_loss50_data <- lorenz_loss50_data %>% 
  clean_names()
```


```{r}
ggplot() + 
  geom_line(data = lorenz_loss20_data, 
            aes(x = cum_perc_households, y = asset_loss), 
            color = "#EB6134") + 
   geom_line(data = lorenz_loss50_data, 
            aes(x = cum_perc_households, y = asset_loss), 
            color = "#3773a3") + 
   geom_abline(intercept = 0, slope = 1, linetype = "dotted", color = "black") +
  labs(x = "Cumulative share of households (%) in order of increasing income",
       y = "Cumulative share of asset losses (%)") +
  theme_bw() 
```

#### 4.3.4 Welfare losses 2020 + 2050

```{r}
ggplot() + 
  geom_line(data = lorenz_loss20_data, 
            aes(x = cum_perc_households, y = welfare_loss), 
            color = "#EB6134") + 
   geom_line(data = lorenz_loss50_data, 
            aes(x = cum_perc_households, y = welfare_loss), 
            color = "#3773a3") + 
   geom_abline(intercept = 0, slope = 1, linetype = "dotted", color = "black") +
  labs(x = "Cumulative share of households (%) in order of increasing income",
       y = "Cumulative share of welfare losses (%)") +
  theme_bw() 
```

